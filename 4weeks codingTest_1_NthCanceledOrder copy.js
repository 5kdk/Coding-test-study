/*
[문제 설명]
온라인으로 주문을 받고 있습니다. 주문 번호는 주문 순서대로 1부터 증가합니다. 주문이 취소될 경우, 해당 주문 번호는 주문 내역에서 제거됩니다.

일부 주문이 취소된 주문 내역이 주어질 경우, n번째 주문 취소된 주문 번호를 구하는 함수, solution을 완성해주세요.

예를 들어, 주문 내역 orders [2, 4, 5, 7]이 있고, 3번째 취소된 주문 번호는 6입니다.

1번째 취소 주문 번호는 1
2번째 취소 주문 번호는 3
3번째 취소 주문 번호는 6

[입력 형식]
\- orders는 길이가 1 이상 1\,000 이하인 배열입니다\.
\- 주문 번호는 최대 1\,000건까지 존재합니다\.
\- n은 1 이상 1\,000 이하의 정수입니다\.
[출력 형식]
\- n번째 취소된 주문 번호를 int 형식으로 구합니다\.
*/


function solution(orders, n) {
    let fillarr = Array.from(new Array(Math.max(...orders)), (x, i) => i + 1);
    let answer = fillarr.filter(ele => orders.includes(ele) == false)
    return answer[n-1]
}

/* 접근방법

1. 주문번호는 1씩 순서대로 증가한다는 것에 영감을 받았습니다.

Array.from()과 매핑함수를 이용해 orders의 가장 큰수만큼의 크기를 가진 Array를 생성하고
그 Array안의 요소들을 1 ~ orders의 가장 큰수로 채워줬습니다.

2. orders 배열에 없는 숫자들이 곧 취소된 주문 번호라는 발상을 했습니다.

orders에 없는 숫자들로만 이루어진 배열을 만들면 그게 취소된 주문 번호가 모인 배열일것이기에
answer 변수에 취소된 주문 번호들만 모은 배열을 생성해주었습니다.

3. 이제 n번째 취소 번호는 answer의 index를 찾아보기만하면 될것입니다. index값에 접근할것이기에
n - 1을 해준 인덱스에 접근하면 정답을 얻습니다.


결과
0.4점 나왔습니다.


이유 예상
주문번호는 최대 1000건까지 존재하니까 Math.max(...orders)값이 최대 주문번호가 아닐 가능성이 있습니다.
예컨대 orders는 [1,2,3,4,5,6,7]이지만 n은 957인 케이스가 있을 수 있으니

안전하게 답을 구하기위해서 fillarr의 크기를 1000으로 선언해두고 값을 구했어야했습니다.
이거때문이 아니면 왜틀렸는지 모르겠음 혹시 다른 예외케이스 있다고 생각하시면 코멘트 남겨주세요




*/